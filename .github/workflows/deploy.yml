name: Deploy a clientes

on:
  push:
    branches:
      - main
      - cliente-*  # Para todas las ramas de clientes

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    # Solo ejecutar si es push a main o rama cliente-*
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/cliente-')

    steps:
      - name: Extract client info from branch
        id: client-info
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Como cada cliente tiene su propio repo, usamos el nombre de la rama como identificador
          if [[ $BRANCH_NAME == cliente-* ]]; then
            CLIENT_ID=${BRANCH_NAME#cliente-}
            echo "client=$CLIENT_ID" >> $GITHUB_OUTPUT
            echo "folder=audio-sender-refactor-$CLIENT_ID" >> $GITHUB_OUTPUT
          else
            echo "client=main" >> $GITHUB_OUTPUT
            echo "folder=audio-sender-refactor-main" >> $GITHUB_OUTPUT
          fi
          
          echo "Branch: $BRANCH_NAME"
          echo "Client: $CLIENT_ID"

      - name: Deploy al cliente ${{ steps.client-info.outputs.client }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT || 2222 }}
          script: |
            set -e  # Salir si hay errores
            
            BRANCH_NAME="${{ steps.client-info.outputs.branch }}"
            CLIENT_ID="${{ steps.client-info.outputs.client }}"
            PROJECT_DIR="$HOME/workspaceandres/clientes/cliente-${CLIENT_ID}/message-sender"
            
            echo "ğŸš€ Iniciando deployment para cliente ${CLIENT_ID}"
            echo "ğŸ“ Directorio: ${PROJECT_DIR}"
            echo "ğŸŒ¿ Rama: ${BRANCH_NAME}"
            
            # Verificar si el directorio existe
            if [ ! -d "${PROJECT_DIR}" ]; then
              echo "âŒ Error: Directorio ${PROJECT_DIR} no existe"
              echo ""
              echo "ğŸ”§ Para configurar este cliente, ejecuta en el servidor:"
              echo "   git clone -b ${BRANCH_NAME} https://github.com/${{ github.repository }}.git ${PROJECT_DIR}"
              echo "   cd ${PROJECT_DIR}"
              echo "   # Configura tu archivo .env especÃ­fico del cliente"
              echo "   # docker compose up -d"
              exit 1
            fi
            
            # Cambiar al directorio del proyecto
            cd "${PROJECT_DIR}"
            
            # Verificar que existe .env
            if [ ! -f ".env" ]; then
              echo "âŒ Error: Archivo .env no encontrado en ${PROJECT_DIR}"
              echo ""
              echo "ğŸ”§ Para configurar este cliente:"
              echo "   1. Crea el archivo .env con las variables necesarias"
              echo "   2. Configura PORT, NODE_ENV, PUBLIC_URL y Keycloak"
              echo "   3. Reinicia el deployment con: git push origin ${BRANCH_NAME}"
              echo "KEYCLOAK_REALM=message-sender"
              echo "KEYCLOAK_AUDIENCE=message-sender-web"
              exit 1
            fi
            
            # Leer el puerto desde el .env para logging
            CLIENT_PORT=$(grep "^PORT=" .env | cut -d'=' -f2 | tr -d ' ')
            if [ -z "$CLIENT_PORT" ]; then
              echo "âŒ Error: PORT no estÃ¡ definido en .env"
              exit 1
            fi
            
            echo "ğŸ“‹ Puerto del cliente: ${CLIENT_PORT} (leÃ­do desde .env)"
            
            # Verificar que Docker estÃ¡ disponible
            if ! command -v docker &> /dev/null; then
              echo "âŒ Error: Docker no estÃ¡ instalado"
              exit 1
            fi
            
            if ! docker compose version &> /dev/null && ! command -v docker-compose &> /dev/null; then
              echo "âŒ Error: Docker Compose no estÃ¡ disponible"
              exit 1
            fi
            
            # Hacer backup del .env antes del pull
            echo "ğŸ’¾ Respaldando configuraciÃ³n actual..."
            cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
            cp .env .env.temp
            
            # Actualizar cÃ³digo desde GitHub
            echo "ğŸ“¥ Actualizando cÃ³digo desde GitHub..."
            git remote set-url origin https://github.com/${{ github.repository }}.git
            git fetch origin
            git reset --hard origin/${BRANCH_NAME}
            
            # Restaurar .env (preservar configuraciÃ³n local)
            mv .env.temp .env
            
            # Crear directorios necesarios si no existen
            echo "ğŸ“ Verificando directorios necesarios..."
            mkdir -p uploads bot_sessions temp logs
            
            # Configurar permisos
            echo "ğŸ” Configurando permisos..."
            chown -R elporavv:elporavv . 2>/dev/null || true
            chmod -R 755 .
            
            # Parar contenedores existentes
            echo "ğŸ›‘ Deteniendo contenedores existentes..."
            docker compose down --remove-orphans || true
            
            # Limpiar imÃ¡genes y contenedores huÃ©rfanos para liberar espacio
            echo "ğŸ§¹ Limpiando recursos Docker..."
            docker container prune -f || true
            docker image prune -f || true
            
            # Construir nueva imagen
            echo "ğŸ”¨ Construyendo nueva imagen Docker..."
            docker compose build --no-cache
            
            # Iniciar contenedores
            echo "ğŸš€ Iniciando contenedores..."
            docker compose up -d
            
            # Esperar a que el servicio estÃ© listo
            echo "â³ Esperando a que el servicio estÃ© listo..."
            sleep 15
            
            # Verificar que el contenedor estÃ¡ corriendo
            echo "âœ… Verificando estado del deployment..."
            
            if docker compose ps | grep -q "Up"; then
              CONTAINER_STATUS=$(docker compose ps --format "table {{.Name}}\t{{.Status}}")
              echo "ğŸ‰ Deployment exitoso para cliente ${CLIENT_ID} en puerto ${CLIENT_PORT}!"
              echo ""
              echo "ğŸ“Š Estado de contenedores:"
              echo "${CONTAINER_STATUS}"
              echo ""
              echo "ğŸŒ Servicio disponible en:"
              echo "   - Local: http://localhost:${CLIENT_PORT}"
              echo "   - Nginx Proxy Manager: Configurar proxy host apuntando a localhost:${CLIENT_PORT}"
              echo ""
              echo "ğŸ“‹ Para ver logs en tiempo real:"
              echo "   docker compose logs -f"
            else
              echo "âŒ Error: El contenedor no estÃ¡ corriendo correctamente"
              echo ""
              echo "ğŸ“‹ Estado de contenedores:"
              docker compose ps
              echo ""
              echo "ğŸ“‹ Ãšltimos logs del contenedor:"
              docker compose logs --tail=30
              echo ""
              echo "ğŸ”§ Para depurar:"
              echo "   cd ${PROJECT_DIR}"
              echo "   docker compose logs -f"
              exit 1
            fi