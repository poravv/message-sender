name: Deploy a clientes

on:
  push:
    branches:
      - main
      - cliente-*  # Para todas las ramas de clientes

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    # Solo ejecutar si es push a main o rama cliente-*
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/cliente-')

    steps:
      - name: Extract client info from branch
        id: client-info
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Como cada cliente tiene su propio repo, usamos el nombre de la rama como identificador
          if [[ $BRANCH_NAME == cliente-* ]]; then
            CLIENT_ID=${BRANCH_NAME#cliente-}
            echo "client=$CLIENT_ID" >> $GITHUB_OUTPUT
            echo "folder=audio-sender-refactor-$CLIENT_ID" >> $GITHUB_OUTPUT
          else
            echo "client=main" >> $GITHUB_OUTPUT
            echo "folder=audio-sender-refactor-main" >> $GITHUB_OUTPUT
          fi
          
          echo "Branch: $BRANCH_NAME"
          echo "Client: $CLIENT_ID"

      - name: Deploy al cliente ${{ steps.client-info.outputs.client }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT || 2222 }}
          script: |
            set -e  # Salir si hay errores
            
            BRANCH_NAME="${{ steps.client-info.outputs.branch }}"
            CLIENT_ID="${{ steps.client-info.outputs.client }}"
            PROJECT_DIR="$HOME/workspaceandres/clientes/cliente-${CLIENT_ID}/message-sender"
            PROJECT_NAME="audio-sender-cliente-${CLIENT_ID}"
            
            echo "üöÄ Iniciando deployment para cliente ${CLIENT_ID}"
            echo "üìÅ Directorio: ${PROJECT_DIR}"
            echo "üåø Rama: ${BRANCH_NAME}"
            
            # Verificar si el directorio existe
            if [ ! -d "${PROJECT_DIR}" ]; then
              echo "‚ùå Error: Directorio ${PROJECT_DIR} no existe"
              echo ""
              echo "üîß Para configurar este cliente, ejecuta en el servidor:"
              echo "   git clone -b ${BRANCH_NAME} https://github.com/${{ github.repository }}.git ${PROJECT_DIR}"
              echo "   cd ${PROJECT_DIR}"
              echo "   # Configura tu archivo .env espec√≠fico del cliente"
              echo "   # docker compose up -d"
              exit 1
            fi
            
            # Cambiar al directorio del proyecto
            cd "${PROJECT_DIR}"
            
            # Verificar que existe .env
            if [ ! -f ".env" ]; then
              echo "‚ùå Error: Archivo .env no encontrado en ${PROJECT_DIR}"
              echo ""
              echo "üîß Para configurar este cliente:"
              echo "   1. Crea el archivo .env con las variables necesarias"
              echo "   2. Configura PORT, NODE_ENV, PUBLIC_URL y Keycloak"
              echo "   3. Reinicia el deployment con: git push origin ${BRANCH_NAME}"
              echo "KEYCLOAK_REALM=message-sender"
              echo "KEYCLOAK_AUDIENCE=message-sender-web"
              exit 1
            fi
            
            # Leer el puerto desde el .env para logging
            CLIENT_PORT=$(grep "^PORT=" .env | cut -d'=' -f2 | tr -d ' ')
            if [ -z "$CLIENT_PORT" ]; then
              echo "‚ùå Error: PORT no est√° definido en .env"
              exit 1
            fi
            
            echo "üìã Puerto del cliente: ${CLIENT_PORT} (le√≠do desde .env)"
            
            # Verificar que Docker est√° disponible
            if ! command -v docker &> /dev/null; then
              echo "‚ùå Error: Docker no est√° instalado"
              exit 1
            fi
            
            if ! docker compose version &> /dev/null && ! command -v docker-compose &> /dev/null; then
              echo "‚ùå Error: Docker Compose no est√° disponible"
              exit 1
            fi
            
            # Hacer backup del .env antes del pull
            echo "üíæ Respaldando configuraci√≥n actual..."
            cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
            cp .env .env.temp
            
            # Actualizar c√≥digo desde GitHub
            echo "üì• Actualizando c√≥digo desde GitHub..."
            git remote set-url origin https://github.com/${{ github.repository }}.git
            git fetch origin
            git reset --hard origin/${BRANCH_NAME}
            
            # Restaurar .env (preservar configuraci√≥n local)
            mv .env.temp .env
            
            # Crear directorios necesarios si no existen
            echo "üìÅ Verificando directorios necesarios..."
            mkdir -p uploads bot_sessions temp logs
            
            # Configurar permisos
            echo "üîê Configurando permisos..."
            chown -R elporavv:elporavv . 2>/dev/null || true
            chmod -R 755 .
            
            # Parar contenedores existentes
            echo "üõë Deteniendo contenedores existentes..."
            docker compose --project-name "${PROJECT_NAME}" down --remove-orphans || true
            
            # Limpiar im√°genes, contenedores y redes hu√©rfanas para liberar espacio
            echo "üßπ Limpiando recursos Docker..."
            docker container prune -f || true
            docker image prune -f || true
            docker network prune -f || true
            
            # Construir nueva imagen
            echo "üî® Construyendo nueva imagen Docker..."
            docker compose --project-name "${PROJECT_NAME}" build --no-cache
            
            # Iniciar contenedores
            echo "üöÄ Iniciando contenedores..."
            docker compose --project-name "${PROJECT_NAME}" up -d
            
            # Esperar a que el servicio est√© listo
            echo "‚è≥ Esperando a que el servicio est√© listo..."
            sleep 15
            
            # Verificar que el contenedor est√° corriendo
            echo "‚úÖ Verificando estado del deployment..."
            
            if docker compose --project-name "${PROJECT_NAME}" ps | grep -q "Up"; then
              CONTAINER_STATUS=$(docker compose --project-name "${PROJECT_NAME}" ps --format "table {{.Name}}\t{{.Status}}")
              echo "üéâ Deployment exitoso para cliente ${CLIENT_ID} en puerto ${CLIENT_PORT}!"
              echo ""
              echo "üìä Estado de contenedores:"
              echo "${CONTAINER_STATUS}"
              echo ""
              echo "üåê Servicio disponible en:"
              echo "   - Local: http://localhost:${CLIENT_PORT}"
              echo "   - Nginx Proxy Manager: Configurar proxy host apuntando a localhost:${CLIENT_PORT}"
              echo ""
              echo "üìã Para ver logs en tiempo real:"
              echo "   docker compose --project-name \"${PROJECT_NAME}\" logs -f"
            else
              echo "‚ùå Error: El contenedor no est√° corriendo correctamente"
              echo ""
              echo "üìã Estado de contenedores:"
              docker compose --project-name "${PROJECT_NAME}" ps
              echo ""
              echo "üìã √öltimos logs del contenedor:"
              docker compose --project-name "${PROJECT_NAME}" logs --tail=30
              echo ""
              echo "üîß Para depurar:"
              echo "   cd ${PROJECT_DIR}"
              echo "   docker compose --project-name \"${PROJECT_NAME}\" logs -f"
              exit 1
            fi