// src/manager.js
const fs = require('fs');
const path = require('path');
const qrcode = require('qrcode');
const { 
  default: makeWASocket, 
  DisconnectReason, 
  useMultiFileAuthState,
  downloadContentFromMessage,
  generateWAMessageFromContent,
  proto,
  prepareWAMessageMedia,
  MediaType
} = require('@whiskeysockets/baileys');
const pino = require('pino');
const { isAuthorizedPhone, publicDir } = require('./config');
const { MessageQueue } = require('./queue');
const logger = require('./logger');

class WhatsAppManager {
  constructor(userId = 'default') {
    this.userId = userId;
    this.sock = null;
    this.isReady = false;
    this.qrCode = null;
    this.connectionState = 'disconnected';
    this.lastActivity = Date.now();
    this.messageQueue = null;
    this.lastQRUpdate = null;
    this.securityAlert = null;
    this.userInfo = null;
    this.authState = null;
    this.saveCreds = null;
    this.authPath = null; // Ruta personalizable para autenticaci√≥n
    
    // Rate limiting y control de conflictos
    this.lastMessageTime = 0;
    this.messageCount = 0;
    this.maxMessagesPerMinute = 15; // L√≠mite m√°s conservador
    this.conflictCount = 0;
    this.lastConflictTime = 0;
    this.isInCooldown = false;
    
    // Mutex para prevenir conexiones concurrentes
    this.isConnecting = false;
    this.connectionPromise = null;
    this.lastDisconnectReason = null;

    // Comp. para controlar cu√°ndo guardar el PNG
    this.qrCaptureRequested = false;
  }

  getState() {
    return {
      isReady: this.isReady,
      connectionState: this.connectionState,
      lastActivity: this.lastActivity,
      lastQRUpdate: this.lastQRUpdate || null,
      hasQR: !!this.qrCode,
      securityAlert: this.securityAlert || null,
      userInfo: this.userInfo || null
    };
  }

  updateActivity() { this.lastActivity = Date.now(); }

  deleteSessionFiles() {
    try {
      logger.info('Eliminando archivos de sesi√≥n...');
      const sessionDir = this.authPath || path.join(publicDir, '..', 'auth_info');
      if (!fs.existsSync(sessionDir)) return logger.info('Directorio de sesiones no encontrado');

      let deleted = 0;
      for (const f of fs.readdirSync(sessionDir)) {
        const p = path.join(sessionDir, f);
        try {
          if (fs.lstatSync(p).isDirectory()) {
            for (const sf of fs.readdirSync(p)) {
              fs.unlinkSync(path.join(p, sf));
              deleted++;
            }
            fs.rmdirSync(p);
          } else {
            fs.unlinkSync(p);
            deleted++;
          }
        } catch (e) {
          logger.error({ p, err: e?.message }, 'Error eliminando archivo de sesi√≥n');
        }
      }
      logger.info({ deleted, sessionDir }, 'Archivos de sesi√≥n eliminados');
    } catch (e) {
      logger.error({ err: e?.message }, 'Error al eliminar archivos de sesi√≥n');
    }
  }

  // ===== Comp. QR: API para la ruta /refresh-qr =====
  requestQrCapture() {
    this.qrCaptureRequested = true;
  }

  async captureQrToDisk(userId = null) {
    try {
      if (!this.qrCode) return false;
      
      // Si tenemos un userId, crear QR espec√≠fico para ese usuario
      const qrFileName = userId ? `qr-${userId}.png` : 'qr.png';
      const qrPath = path.join(publicDir, qrFileName);
      
      await qrcode.toFile(qrPath, this.qrCode, {
        color: { dark: '#128C7E', light: '#FFFFFF' },
        width: 300,
        margin: 1
      });
      this.lastQRUpdate = Date.now();
      logger.info({ qrPath, userId }, 'QR guardado (captura inmediata)');
      return true;
    } catch (e) {
      logger.error({ err: e?.message }, 'captureQrToDisk fall√≥');
      return false;
    }
  }

  // M√©todo seguro para inicializar que evita conexiones concurrentes
  async safeInitialize() {
    // Si ya hay una conexi√≥n en progreso, esperar a que termine
    if (this.isConnecting) {
      logger.warn('Conexi√≥n ya en progreso, esperando...');
      if (this.connectionPromise) {
        try {
          await this.connectionPromise;
        } catch (err) {
          logger.warn('Conexi√≥n anterior fall√≥, continuando con nueva conexi√≥n');
        }
      }
      return;
    }

    // Si est√° en cooldown, no conectar
    if (this.isInCooldown) {
      logger.warn('En cooldown, cancelando intento de conexi√≥n');
      return;
    }

    // Marcar como conectando y guardar promesa
    this.isConnecting = true;
    this.connectionPromise = this.initialize()
      .catch(err => {
        logger.error({ err: err?.message }, 'Error en inicializaci√≥n segura');
        throw err;
      })
      .finally(() => {
        this.isConnecting = false;
        this.connectionPromise = null;
      });

    return this.connectionPromise;
  }

  async initialize() {
    if (this.sock) {
      logger.info('Socket ya inicializado, reutilizando...');
      return true;
    }

    try {
      // Configurar autenticaci√≥n
      const authDir = this.authPath || path.join(publicDir, '..', 'auth_info');
      if (!fs.existsSync(authDir)) {
        fs.mkdirSync(authDir, { recursive: true });
      }

      const { state, saveCreds } = await useMultiFileAuthState(authDir);
      this.authState = state;
      this.saveCreds = saveCreds;

      // Crear socket
      this.sock = makeWASocket({
        auth: state,
        printQRInTerminal: false,
        logger: pino({ level: 'silent' }), // Logger compatible con Baileys
        connectTimeoutMs: 60000,
        defaultQueryTimeoutMs: 0,
        keepAliveIntervalMs: 10000,
        markOnlineOnConnect: false
      });

      // Event handlers
      this.sock.ev.on('creds.update', saveCreds);

      this.sock.ev.on('connection.update', async (update) => {
        const { connection, lastDisconnect, qr } = update;

        if (qr) {
          this.qrCode = qr;
          this.connectionState = 'qr_ready';

          // Obtener userId desde authPath si est√° disponible
          const userId = this.authPath ? path.basename(this.authPath).replace('user-', '') : null;
          const qrFileName = userId ? `qr-${userId}.png` : 'qr.png';
          const qrPath = path.join(publicDir, qrFileName);
          
          const shouldWrite = this.qrCaptureRequested || !fs.existsSync(qrPath);

          if (shouldWrite) {
            this.qrCaptureRequested = false;
            logger.info({ userId }, 'QR Code recibido');
            await qrcode.toFile(qrPath, qr, {
              color: { dark: '#128C7E', light: '#FFFFFF' },
              width: 300,
              margin: 1
            });
            logger.info({ qrPath, userId }, 'QR guardado');
            this.lastQRUpdate = Date.now();
          }
        }

        if (connection === 'close') {
          const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
          const reason = lastDisconnect?.error?.message;
          
          this.lastDisconnectReason = reason;
          
          logger.warn({ 
            reason,
            shouldReconnect,
            userId: this.authPath ? path.basename(this.authPath).replace('user-', '') : null
          }, 'Conexi√≥n cerrada');
          
          this.isReady = false;
          this.connectionState = 'disconnected';
          this.userInfo = null;
          this.sock = null;
          this.isConnecting = false; // Reset mutex

          // Manejar diferentes tipos de desconexi√≥n
          if (reason && reason.includes('QR refs attempts ended')) {
            logger.warn('Sesi√≥n cerrada por timeout de QR. Esperando antes de reconectar...');
            // QR timeout - esperar m√°s tiempo antes de reconectar
            if (shouldReconnect) {
              setTimeout(() => {
                logger.info('Reintentando conexi√≥n tras QR timeout...');
                this.safeInitialize();
              }, 30000); // 30 segundos para QR timeout
            }
            return;
          }

          // Evitar reconexi√≥n en caso de conflictos
          if (reason && reason.includes('conflict')) {
            this.conflictCount++;
            this.lastConflictTime = Date.now();
            
            logger.warn(`Conflicto detectado (#${this.conflictCount}). Implementando estrategia de reconexi√≥n inteligente`);
            
            // Cooldown escalado basado en n√∫mero de conflictos
            const cooldownMinutes = Math.min(this.conflictCount * 2, 10); // M√°ximo 10 minutos
            const cooldownMs = cooldownMinutes * 60 * 1000;
            
            this.isInCooldown = true;
            
            logger.info(`Entrando en cooldown por ${cooldownMinutes} minutos debido a conflicto`);
            
            setTimeout(() => {
              this.isInCooldown = false;
              logger.info('Cooldown terminado, intentando reconexi√≥n despu√©s de conflicto');
              this.safeInitialize();
            }, cooldownMs);
            
            return;
          }

          if (shouldReconnect) {
            // Reset contador de conflictos en desconexiones normales
            if (!reason || !reason.includes('conflict')) {
              this.conflictCount = Math.max(0, this.conflictCount - 1);
            }
            
            // Delay m√°s largo para evitar conflictos, escalado si hay historial de conflictos
            const baseDelay = 15000; // 15 segundos base
            const conflictPenalty = this.conflictCount * 5000; // 5 segundos adicionales por conflicto previo
            const totalDelay = baseDelay + conflictPenalty;
            
            setTimeout(() => {
              logger.info(`Reintentando conexi√≥n (delay: ${totalDelay}ms, conflictos previos: ${this.conflictCount})...`);
              this.safeInitialize();
            }, totalDelay);
          }
        } else if (connection === 'open') {
          logger.info('Conexi√≥n abierta');
          this.connectionState = 'connected';

          // Obtener informaci√≥n del usuario
          if (this.sock?.user) {
            const phoneNumber = this.sock.user.id.split(':')[0];
            
            // Log para ver qu√© propiedades est√°n disponibles
            logger.info({ userObject: this.sock.user }, 'Propiedades disponibles del usuario');
            
            // Establecer informaci√≥n b√°sica del usuario
            // En Baileys, el pushname se obtiene mejor desde mensajes o contactos
            // Por ahora usamos el n√∫mero como identificador principal
            const pushname = `Usuario ${phoneNumber}`;
            
            this.userInfo = {
              phoneNumber: phoneNumber,
              pushname: pushname,
              jid: this.sock.user.id
            };
            logger.info({ userInfo: this.userInfo }, 'Informaci√≥n del usuario obtenida');

            // Verificar si est√° autorizado
            if (!isAuthorizedPhone(phoneNumber)) {
              const alert = `¬°ALERTA! N√∫mero no autorizado: ${phoneNumber}`;
              logger.warn({ phoneNumber }, 'N√∫mero no autorizado, desconectando...');
              this.securityAlert = { 
                timestamp: Date.now(), 
                messages: [alert, 'Desconectando...'], 
                phoneNumber 
              };
              
              // Enviar mensaje de advertencia y desconectar
              try {
                await this.sock.sendMessage(this.sock.user.id, { 
                  text: 'N√∫mero no autorizado. Se cerrar√° la sesi√≥n.' 
                });
              } catch {}
              
              this.isReady = false;
              this.connectionState = 'unauthorized';
              
              setTimeout(async () => {
                try {
                  await this.sock?.logout();
                  this.sock = null;
                  this.deleteSessionFiles();
                  setTimeout(() => this.initialize(), 8000);
                } catch {}
              }, 3000);
              return;
            }

            logger.info({ phoneNumber }, 'N√∫mero autorizado');
            this.isReady = true;
            this.lastActivity = Date.now();
            
            // Eliminar QR una vez conectado (espec√≠fico del usuario)
            const userId = this.authPath ? path.basename(this.authPath).replace('user-', '') : null;
            const qrFileName = userId ? `qr-${userId}.png` : 'qr.png';
            const qrPath = path.join(publicDir, qrFileName);
            
            try { 
              if (fs.existsSync(qrPath)) {
                fs.unlinkSync(qrPath); 
                logger.info({ userId, qrPath }, 'QR eliminado tras conexi√≥n exitosa');
              }
            } catch {}
          }
        } else if (connection === 'connecting') {
          logger.info('Conectando...');
          this.connectionState = 'connecting';
        }
      });

      // Configurar cola de mensajes con userId
      this.messageQueue = new MessageQueue(this.sock, this.userId);
      
      return true;
    } catch (e) {
      logger.error({ err: e?.message }, 'Error inicializando Baileys');
      return false;
    }
  }

  async refreshQR() {
    logger.info('Solicitando refrescar QR...');
    if (this.isReady) { 
      logger.info('No se puede refrescar: ya autenticado'); 
      return false; 
    }

    try {
      if (this.sock) {
        logger.info('Cerrando socket actual...');
        try { 
          await this.sock.logout(); 
        } catch {}
        this.sock = null;
      }

      // Eliminar QR espec√≠fico del usuario
      const userId = this.authPath ? path.basename(this.authPath).replace('user-', '') : null;
      const qrFileName = userId ? `qr-${userId}.png` : 'qr.png';
      const qrPath = path.join(publicDir, qrFileName);
      
      try { 
        if (fs.existsSync(qrPath)) {
          fs.unlinkSync(qrPath); 
          logger.info({ userId, qrPath }, 'QR anterior eliminado'); 
        }
      } catch {}
      
      this.isReady = false; 
      this.qrCode = null; 
      this.connectionState = 'disconnected';
      this.userInfo = null;
      this.deleteSessionFiles();

      // preparar compuerta para el pr√≥ximo evento 'qr'
      this.requestQrCapture();

      await new Promise(r => setTimeout(r, 2000));
      logger.info({ userId }, 'Inicializando nuevo socket...');
      await this.safeInitialize();
      logger.info({ userId }, 'Nuevo socket inicializado, esperando QR...');
      return true;
    } catch (e) {
      logger.error({ err: e?.message }, 'Error al refrescar QR');
      return false;
    }
  }

  // M√©todos para rate limiting y manejo de conflictos
  checkRateLimit() {
    const now = Date.now();
    const oneMinuteAgo = now - (60 * 1000);
    
    // Reset contador si ha pasado m√°s de un minuto
    if (now - this.lastMessageTime > 60000) {
      this.messageCount = 0;
    }
    
    return this.messageCount < this.maxMessagesPerMinute;
  }
  
  recordMessage() {
    const now = Date.now();
    this.lastMessageTime = now;
    this.messageCount++;
    
    logger.info(`Mensaje registrado: ${this.messageCount}/${this.maxMessagesPerMinute} en la √∫ltima hora`);
    
    // Si estamos cerca del l√≠mite, registrar advertencia
    if (this.messageCount >= this.maxMessagesPerMinute * 0.8) {
      logger.warn(`Cerca del l√≠mite de rate: ${this.messageCount}/${this.maxMessagesPerMinute}`);
    }
  }
  
  async waitForRateLimit() {
    if (!this.checkRateLimit()) {
      const waitTime = 60000; // Esperar 1 minuto
      logger.warn(`Rate limit alcanzado. Esperando ${waitTime/1000} segundos...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
      this.messageCount = 0; // Reset contador despu√©s del cooldown
    }
  }
  
  isInConflictCooldown() {
    if (!this.isInCooldown) return false;
    
    const now = Date.now();
    const timeSinceLastConflict = now - this.lastConflictTime;
    const cooldownDuration = Math.min(this.conflictCount * 2 * 60 * 1000, 10 * 60 * 1000);
    
    return timeSinceLastConflict < cooldownDuration;
  }
  
  getConnectionHealth() {
    return {
      isReady: this.isReady,
      connectionState: this.connectionState,
      conflictCount: this.conflictCount,
      messageCount: this.messageCount,
      maxMessagesPerMinute: this.maxMessagesPerMinute,
      isInCooldown: this.isInCooldown,
      lastConflictTime: this.lastConflictTime,
      isConnecting: this.isConnecting,
      lastDisconnectReason: this.lastDisconnectReason,
      canSendMessages: this.isReady && !this.isInCooldown && this.checkRateLimit() && !this.isConnecting
    };
  }

  // M√©todo para cerrar sesi√≥n de WhatsApp completamente
  async logout() {
    try {
      logger.info(`Cerrando sesi√≥n de WhatsApp para usuario ${this.userId}`);
      
      // 1. Marcar como no listo inmediatamente
      this.isReady = false;
      this.connectionState = 'logging_out';
      
      // 2. Si hay un socket activo, hacer logout AGRESIVO
      if (this.sock) {
        try {
          logger.info('Enviando logout a WhatsApp...');
          
          // NUEVO: Enviar mensaje de desconexi√≥n expl√≠cito antes del logout
          try {
            if (this.sock.user) {
              await this.sock.sendMessage(this.sock.user.id, { 
                text: 'üö™ Cerrando sesi√≥n desde WhatsApp Web...' 
              });
            }
          } catch (msgError) {
            logger.warn('No se pudo enviar mensaje de despedida');
          }
          
          // Logout principal
          await this.sock.logout();
          logger.info('Logout enviado exitosamente a WhatsApp');
          
          // NUEVO: Forzar cierre de conexi√≥n adicional
          if (this.sock.ws) {
            try {
              this.sock.ws.close(1000, 'User logout');
            } catch (wsError) {
              logger.warn('Error cerrando WebSocket manualmente');
            }
          }
          
        } catch (logoutError) {
          logger.warn(`Error durante logout de WhatsApp: ${logoutError.message}`);
          
          // FALLBACK: Si el logout normal falla, forzar desconexi√≥n
          logger.info('Intentando desconexi√≥n forzada...');
          try {
            if (this.sock.end && typeof this.sock.end === 'function') {
              this.sock.end();
            }
            if (this.sock.ws && this.sock.ws.close) {
              this.sock.ws.close(1000, 'Forced logout');
            }
          } catch (forceError) {
            logger.warn('Error en desconexi√≥n forzada');
          }
        }
        
        this.sock = null;
      }
      
      // 3. Limpiar estado completamente
      this.isReady = false;
      this.connectionState = 'disconnected';
      this.userInfo = null;
      this.qrCode = null;
      this.isConnecting = false;
      this.connectionPromise = null;
      
      // 4. IMPORTANTE: Eliminar archivos de sesi√≥n COMPLETAMENTE
      await this.deleteSessionFilesCompletely();
      
      // 5. Eliminar QR si existe
      const userId = this.authPath ? path.basename(this.authPath).replace('user-', '') : this.userId;
      const qrFileName = `qr-${userId}.png`;
      const qrPath = path.join(publicDir, qrFileName);
      
      try {
        if (fs.existsSync(qrPath)) {
          fs.unlinkSync(qrPath);
          logger.info(`QR eliminado: ${qrPath}`);
        }
      } catch (qrError) {
        logger.warn(`Error eliminando QR: ${qrError.message}`);
      }
      
      logger.info(`Sesi√≥n de WhatsApp cerrada COMPLETAMENTE para usuario ${this.userId}`);
      return true;
      
    } catch (error) {
      logger.error(`Error durante logout completo: ${error.message}`, error);
      
      // Forzar limpieza aunque haya errores
      this.isReady = false;
      this.connectionState = 'disconnected';
      this.sock = null;
      await this.deleteSessionFilesCompletely();
      
      throw error;
    }
  }

  // M√©todo de logout robusto con m√∫ltiples intentos y verificaci√≥n
  async robustLogout() {
    console.log(`üö™ [${this.userId}] Iniciando logout robusto de WhatsApp...`);
    
    const maxAttempts = 3;
    const results = {
      success: false,
      attempts: [],
      finalState: null
    };
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      console.log(`üîÑ [${this.userId}] Intento de logout ${attempt}/${maxAttempts}`);
      
      try {
        const attemptResult = await this.performLogoutAttempt(attempt);
        results.attempts.push(attemptResult);
        
        // Verificar estado despu√©s del intento
        const stateCheck = await this.verifyLogoutState();
        
        if (stateCheck.fullyDisconnected) {
          console.log(`‚úÖ [${this.userId}] Logout exitoso en intento ${attempt}`);
          results.success = true;
          results.finalState = stateCheck;
          break;
        } else {
          console.log(`‚ö†Ô∏è [${this.userId}] Intento ${attempt} incompleto, reintentando...`);
          await this.delay(2000 * attempt); // Delay progresivo
        }
        
      } catch (error) {
        console.error(`‚ùå [${this.userId}] Error en intento ${attempt}:`, error);
        results.attempts.push({ attempt, error: error.message, success: false });
        
        if (attempt < maxAttempts) {
          await this.delay(3000 * attempt);
        }
      }
    }
    
    // Verificaci√≥n final
    results.finalState = await this.verifyLogoutState();
    
    if (!results.success) {
      console.log(`üîß [${this.userId}] Logout robusto fall√≥, aplicando limpieza forzada...`);
      await this.forceCleanup();
      results.finalState = await this.verifyLogoutState();
    }
    
    console.log(`üéØ [${this.userId}] Logout robusto completado:`, results);
    return results;
  }
  
  // Realizar un intento individual de logout
  async performLogoutAttempt(attemptNumber) {
    const result = { attempt: attemptNumber, steps: [], success: false };
    
    try {
      // Usar el m√©todo logout existente como base
      const logoutResult = await this.logout();
      result.steps.push('base_logout_executed');
      result.success = logoutResult;
      
      // Verificaciones adicionales espec√≠ficas del intento
      if (this.sock) {
        // Intentar desconexi√≥n adicional si a√∫n hay socket
        try {
          if (this.sock.ws && this.sock.ws.readyState === 1) {
            this.sock.ws.terminate();
            result.steps.push('websocket_terminated');
          }
        } catch (wsError) {
          result.steps.push('websocket_error');
        }
        
        this.sock = null;
        result.steps.push('socket_nullified');
      }
      
      return result;
      
    } catch (error) {
      result.error = error.message;
      result.steps.push('attempt_failed');
      return result;
    }
  }
  
  // Verificar estado de logout
  async verifyLogoutState() {
    const state = {
      socketNull: this.sock === null,
      notReady: !this.isReady,
      disconnectedState: this.connectionState === 'disconnected',
      noUserInfo: this.userInfo === null,
      filesClean: false,
      qrClean: false,
      fullyDisconnected: false
    };
    
    // Verificar archivos de sesi√≥n
    try {
      const authDir = this.authPath;
      const credsPath = path.join(authDir, 'creds.json');
      state.filesClean = !fs.existsSync(credsPath);
    } catch (error) {
      console.log(`‚ö†Ô∏è [${this.userId}] Error verificando archivos:`, error.message);
      state.filesClean = true; // Asumir limpio si hay error
    }
    
    // Verificar QR
    try {
      const qrFileName = `qr-${this.userId}.png`;
      const qrPath = path.join(publicDir, qrFileName);
      state.qrClean = !fs.existsSync(qrPath);
    } catch (error) {
      state.qrClean = true;
    }
    
    // Estado completamente desconectado
    state.fullyDisconnected = state.socketNull && 
                              state.notReady && 
                              state.disconnectedState && 
                              state.noUserInfo && 
                              state.filesClean && 
                              state.qrClean;
    
    return state;
  }
  
  // Limpieza forzada como √∫ltimo recurso
  async forceCleanup() {
    console.log(`üî® [${this.userId}] Aplicando limpieza forzada...`);
    
    try {
      // Forzar cierre de socket
      if (this.sock) {
        try {
          if (this.sock.ws) {
            this.sock.ws.terminate();
          }
          if (this.sock.end && typeof this.sock.end === 'function') {
            this.sock.end();
          }
        } catch (e) {
          console.log(`‚ö†Ô∏è [${this.userId}] Error terminando socket:`, e.message);
        }
        
        this.sock = null;
      }
      
      // Resetear todo el estado agresivamente
      this.isReady = false;
      this.connectionState = 'disconnected';
      this.userInfo = null;
      this.qrCode = null;
      this.isConnecting = false;
      this.connectionPromise = null;
      
      // Eliminar archivos de sesi√≥n de forma agresiva
      if (this.authPath && fs.existsSync(this.authPath)) {
        await fs.promises.rm(this.authPath, { recursive: true, force: true });
        console.log(`üóëÔ∏è [${this.userId}] Carpeta de sesi√≥n eliminada forzadamente`);
      }
      
      // Eliminar QR
      const qrFileName = `qr-${this.userId}.png`;
      const qrPath = path.join(publicDir, qrFileName);
      if (fs.existsSync(qrPath)) {
        fs.unlinkSync(qrPath);
        console.log(`üóëÔ∏è [${this.userId}] QR eliminado forzadamente`);
      }
      
      console.log(`‚úÖ [${this.userId}] Limpieza forzada completada`);
      
    } catch (error) {
      console.error(`‚ùå [${this.userId}] Error en limpieza forzada:`, error);
    }
  }
  
  // M√©todo utilitario para delays
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // M√©todo mejorado para eliminar archivos de sesi√≥n COMPLETAMENTE
  async deleteSessionFilesCompletely() {
    try {
      logger.info('Eliminando archivos de sesi√≥n COMPLETAMENTE...');
      const sessionDir = this.authPath || path.join(publicDir, '..', 'auth_info');
      
      if (!fs.existsSync(sessionDir)) {
        logger.info('Directorio de sesiones no existe');
        return;
      }

      let deleted = 0;
      const files = fs.readdirSync(sessionDir);
      
      for (const file of files) {
        const filePath = path.join(sessionDir, file);
        try {
          const stat = fs.lstatSync(filePath);
          
          if (stat.isDirectory()) {
            // Eliminar contenido del directorio recursivamente
            const subFiles = fs.readdirSync(filePath);
            for (const subFile of subFiles) {
              const subFilePath = path.join(filePath, subFile);
              fs.unlinkSync(subFilePath);
              deleted++;
            }
            fs.rmdirSync(filePath);
            deleted++;
          } else {
            fs.unlinkSync(filePath);
            deleted++;
          }
        } catch (error) {
          logger.error(`Error eliminando ${filePath}: ${error.message}`);
        }
      }
      
      // Intentar eliminar el directorio padre si est√° vac√≠o
      try {
        if (fs.readdirSync(sessionDir).length === 0) {
          fs.rmdirSync(sessionDir);
          deleted++;
        }
      } catch (dirError) {
        logger.warn('No se pudo eliminar directorio padre (puede no estar vac√≠o)');
      }
      
      logger.info(`Archivos de sesi√≥n eliminados COMPLETAMENTE: ${deleted} elementos`);
      
      // NUEVO: Tambi√©n limpiar cualquier archivo de credenciales en memoria
      this.authState = null;
      this.saveCreds = null;
      
    } catch (error) {
      logger.error(`Error al eliminar archivos de sesi√≥n completamente: ${error.message}`);
      throw error;
    }
  }

  // M√©todo para forzar desconexi√≥n sin logout (para casos de emergencia)
  async forceDisconnect() {
    try {
      logger.info(`Forzando desconexi√≥n para usuario ${this.userId}`);
      
      if (this.sock) {
        try {
          if (this.sock.end && typeof this.sock.end === 'function') {
            this.sock.end();
          }
        } catch (error) {
          logger.warn(`Error en force disconnect: ${error.message}`);
        }
        this.sock = null;
      }
      
      this.isReady = false;
      this.connectionState = 'disconnected';
      this.userInfo = null;
      this.qrCode = null;
      this.isConnecting = false;
      this.connectionPromise = null;
      
      this.deleteSessionFiles();
      
      logger.info(`Desconexi√≥n forzada completada para usuario ${this.userId}`);
      return true;
      
    } catch (error) {
      logger.error(`Error durante desconexi√≥n forzada: ${error.message}`);
      return false;
    }
  }

  // M√©todo de logout b√°sico para cerrar sesi√≥n de WhatsApp
  async logout() {
    try {
      logger.info(`Cerrando sesi√≥n de WhatsApp para usuario ${this.userId}`);
      
      // 1. Marcar como no listo inmediatamente
      this.isReady = false;
      this.connectionState = 'logging_out';
      
      // 2. Si hay un socket activo, hacer logout
      if (this.sock) {
        try {
          logger.info('Enviando logout a WhatsApp...');
          
          // Logout principal
          await this.sock.logout();
          logger.info('Logout enviado exitosamente a WhatsApp');
          
          // Forzar cierre de conexi√≥n adicional
          if (this.sock.ws) {
            try {
              this.sock.ws.close(1000, 'User logout');
            } catch (wsError) {
              logger.warn('Error cerrando WebSocket manualmente');
            }
          }
          
        } catch (logoutError) {
          logger.warn(`Error durante logout de WhatsApp: ${logoutError.message}`);
          
          // FALLBACK: Si el logout normal falla, forzar desconexi√≥n
          logger.info('Intentando desconexi√≥n forzada...');
          try {
            if (this.sock.end && typeof this.sock.end === 'function') {
              this.sock.end();
            }
            if (this.sock.ws && this.sock.ws.close) {
              this.sock.ws.close(1000, 'Forced logout');
            }
          } catch (forceError) {
            logger.warn('Error en desconexi√≥n forzada');
          }
        }
        
        this.sock = null;
      }
      
      // 3. Limpiar estado completamente
      this.isReady = false;
      this.connectionState = 'disconnected';
      this.userInfo = null;
      this.qrCode = null;
      this.isConnecting = false;
      this.connectionPromise = null;
      
      // 4. Eliminar archivos de sesi√≥n
      await this.deleteSessionFiles();
      
      logger.info(`Sesi√≥n de WhatsApp cerrada COMPLETAMENTE para usuario ${this.userId}`);
      return true;
      
    } catch (error) {
      logger.error(`Error durante logout completo: ${error.message}`, error);
      
      // Forzar limpieza aunque haya errores
      this.isReady = false;
      this.connectionState = 'disconnected';
      this.sock = null;
      await this.deleteSessionFiles();
      
      throw error;
    }
  }

  // M√©todo de logout robusto con m√∫ltiples intentos y verificaci√≥n
  async robustLogout() {
    console.log(`üö™ [${this.userId}] Iniciando logout robusto de WhatsApp...`);
    
    const maxAttempts = 3;
    const results = {
      success: false,
      attempts: [],
      finalState: null
    };
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      console.log(`üîÑ [${this.userId}] Intento de logout ${attempt}/${maxAttempts}`);
      
      try {
        const attemptResult = await this.performLogoutAttempt(attempt);
        results.attempts.push(attemptResult);
        
        // Verificar estado despu√©s del intento
        const stateCheck = await this.verifyLogoutState();
        
        if (stateCheck.fullyDisconnected) {
          console.log(`‚úÖ [${this.userId}] Logout exitoso en intento ${attempt}`);
          results.success = true;
          results.finalState = stateCheck;
          break;
        } else {
          console.log(`‚ö†Ô∏è [${this.userId}] Intento ${attempt} incompleto, reintentando...`);
          await this.delay(2000 * attempt); // Delay progresivo
        }
        
      } catch (error) {
        console.error(`‚ùå [${this.userId}] Error en intento ${attempt}:`, error);
        results.attempts.push({ attempt, error: error.message, success: false });
        
        if (attempt < maxAttempts) {
          await this.delay(3000 * attempt);
        }
      }
    }
    
    // Verificaci√≥n final
    results.finalState = await this.verifyLogoutState();
    
    if (!results.success) {
      console.log(`üîß [${this.userId}] Logout robusto fall√≥, aplicando limpieza forzada...`);
      await this.forceCleanup();
      results.finalState = await this.verifyLogoutState();
    }
    
    console.log(`üéØ [${this.userId}] Logout robusto completado:`, results);
    return results;
  }
  
  // Realizar un intento individual de logout
  async performLogoutAttempt(attemptNumber) {
    const result = { attempt: attemptNumber, steps: [], success: false };
    
    try {
      // Usar el m√©todo logout existente como base
      const logoutResult = await this.logout();
      result.steps.push('base_logout_executed');
      result.success = logoutResult;
      
      // Verificaciones adicionales espec√≠ficas del intento
      if (this.sock) {
        // Intentar desconexi√≥n adicional si a√∫n hay socket
        try {
          if (this.sock.ws && this.sock.ws.readyState === 1) {
            this.sock.ws.terminate();
            result.steps.push('websocket_terminated');
          }
        } catch (wsError) {
          result.steps.push('websocket_error');
        }
        
        this.sock = null;
        result.steps.push('socket_nullified');
      }
      
      return result;
      
    } catch (error) {
      result.error = error.message;
      result.steps.push('attempt_failed');
      return result;
    }
  }
  
  // Verificar estado de logout
  async verifyLogoutState() {
    const state = {
      socketNull: this.sock === null,
      notReady: !this.isReady,
      disconnectedState: this.connectionState === 'disconnected',
      noUserInfo: this.userInfo === null,
      filesClean: false,
      qrClean: false,
      fullyDisconnected: false
    };
    
    // Verificar archivos de sesi√≥n
    try {
      const authDir = this.authPath;
      const credsPath = path.join(authDir, 'creds.json');
      state.filesClean = !fs.existsSync(credsPath);
    } catch (error) {
      console.log(`‚ö†Ô∏è [${this.userId}] Error verificando archivos:`, error.message);
      state.filesClean = true; // Asumir limpio si hay error
    }
    
    // Verificar QR
    try {
      const qrFileName = `qr-${this.userId}.png`;
      const qrPath = path.join(publicDir, qrFileName);
      state.qrClean = !fs.existsSync(qrPath);
    } catch (error) {
      state.qrClean = true;
    }
    
    // Estado completamente desconectado
    state.fullyDisconnected = state.socketNull && 
                              state.notReady && 
                              state.disconnectedState && 
                              state.noUserInfo && 
                              state.filesClean && 
                              state.qrClean;
    
    return state;
  }
  
  // Limpieza forzada como √∫ltimo recurso
  async forceCleanup() {
    console.log(`üî® [${this.userId}] Aplicando limpieza forzada...`);
    
    try {
      // Forzar cierre de socket
      if (this.sock) {
        try {
          if (this.sock.ws) {
            this.sock.ws.terminate();
          }
          if (this.sock.end && typeof this.sock.end === 'function') {
            this.sock.end();
          }
        } catch (e) {
          console.log(`‚ö†Ô∏è [${this.userId}] Error terminando socket:`, e.message);
        }
        
        this.sock = null;
      }
      
      // Resetear todo el estado agresivamente
      this.isReady = false;
      this.connectionState = 'disconnected';
      this.userInfo = null;
      this.qrCode = null;
      this.isConnecting = false;
      this.connectionPromise = null;
      
      // Eliminar archivos de sesi√≥n de forma agresiva
      if (this.authPath && fs.existsSync(this.authPath)) {
        await fs.promises.rm(this.authPath, { recursive: true, force: true });
        console.log(`üóëÔ∏è [${this.userId}] Carpeta de sesi√≥n eliminada forzadamente`);
      }
      
      // Eliminar QR
      const qrFileName = `qr-${this.userId}.png`;
      const qrPath = path.join(publicDir, qrFileName);
      if (fs.existsSync(qrPath)) {
        fs.unlinkSync(qrPath);
        console.log(`üóëÔ∏è [${this.userId}] QR eliminado forzadamente`);
      }
      
      console.log(`‚úÖ [${this.userId}] Limpieza forzada completada`);
      
    } catch (error) {
      console.error(`‚ùå [${this.userId}] Error en limpieza forzada:`, error);
    }
  }
  
  // M√©todo utilitario para delays
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = { WhatsAppManager };